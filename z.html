<!doctype html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>原生虚拟化可拖拽树（Flat Data）</title>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <style>
        :root{
            --row-h:36px;
            --indent:18px;
            --border:#e6e6e6;
            --accent:#409eff;
            --bg:#fff;
        }
        html,body{height:100%;margin:0;font-family:Segoe UI, Roboto, Arial;}
        #app{height:100vh;display:flex;flex-direction:column;padding:10px;box-sizing:border-box}
        .toolbar{display:flex;gap:8px;margin-bottom:8px}
        .toolbar input{flex:1;padding:6px}
        .tree-wrap{flex:1;border:1px solid var(--border);position:relative;overflow:auto;background:var(--bg)}
        .phantom{width:100%;pointer-events:none}
        .window{position:absolute;left:0;top:0;width:100%}
        .row{box-sizing:border-box;display:flex;align-items:center;height:var(--row-h);line-height:var(--row-h);border-bottom:1px solid rgba(0,0,0,0.03);padding-right:8px;user-select:none}
        .toggle{width:18px;display:inline-block;cursor:pointer;text-align:center}
        .label{padding-left:6px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
        .drop-indicator{position:absolute;height:2px;background:var(--accent);left:0;display:none;z-index:20}
        .row.dragging{opacity:0.5}
        .row.over-inside{outline:1px dashed rgba(64,158,255,0.6)}
        mark{background:#ffc}
        .icon{width:16px;height:16px;margin-right:6px;display:inline-block}
        .controls{display:flex;gap:8px}
        button{padding:6px 8px}
    </style>
</head>
<body>
<div id="app">
    <div class="toolbar">
        <input id="search" placeholder="搜索（保留匹配节点 + 父节点 + 直属子节点）" />
        <div class="controls">
            <button id="btn-refresh">刷新</button>
            <button id="btn-expand-all">全部展开</button>
            <button id="btn-collapse-all">全部收起</button>
        </div>
    </div>

    <div id="tree" class="tree-wrap">
        <div id="phantom" class="phantom"></div>
        <div id="window" class="window"></div>
        <div id="drop-indicator" class="drop-indicator"></div>
    </div>
</div>

<script>
    /*
      原生虚拟化可拖拽树（单文件）
      - flatData: 扁平节点数组（id, label, type, parentId, level, hasChildren, expanded）
      - visibleList: 由 expanded 计算出的可见节点（用于虚拟化）
      - 支持搜索：保留匹配节点 + 所有父节点 + 直属子节点
      - 拖拽：支持 before/after/inside（通过光标在目标行的垂直位置判断）
    */

    // ---------- 配置 ----------
    const ITEM_H = 36;
    const BUFFER = 6;
    const INDENT = 18;
    // ---------- DOM ----------
    const container = document.getElementById('tree');
    const phantom = document.getElementById('phantom');
    const win = document.getElementById('window');
    const dropIndicator = document.getElementById('drop-indicator');
    const searchInput = document.getElementById('search');
    const btnRefresh = document.getElementById('btn-refresh');
    const btnExpandAll = document.getElementById('btn-expand-all');
    const btnCollapseAll = document.getElementById('btn-collapse-all');

    // ---------- 模拟数据库表格数据（示例） ----------
    // workspace / portfolio / file 三张表（可替换为真实后端数据）
    const workspaces = [
        { id: 1, name: '默认工作空间' },
        { id: 2, name: '第二磁盘' }
    ];
    const portfolios = [
        { id: 1, name: '图片', connected_workspace: 1, associated_folder: null },
        { id: 2, name: '表情', connected_workspace: 1, associated_folder: 1 },
        { id: 3, name: '文档', connected_workspace: 1, associated_folder: null },
        { id: 4, name: '项目A', connected_workspace: 2, associated_folder: null },
    ];
    const files = [
        { id: 1, name: 'fmt1.png', connected_workspace:1, associated_folder:1, file_size:17193 },
        { id: 2, name: 'hello.txt', connected_workspace:1, associated_folder:3, file_size:1234 },
        { id: 3, name: 'pic2.png', connected_workspace:1, associated_folder:2, file_size:9999 },
        { id: 4, name: 'readme.md', connected_workspace:2, associated_folder:null, file_size:234 }
    ];

    // ---------- 将三张表构建成扁平化节点列表 ----------
    function buildFlat() {
        // 建 children 映射
        const wsChildren = new Map();
        const folderChildren = new Map();

        portfolios.forEach(p => {
            if (p.associated_folder == null) {
                if (!wsChildren.has(p.connected_workspace)) wsChildren.set(p.connected_workspace, []);
                wsChildren.get(p.connected_workspace).push({...p, __kind:'folder'});
            } else {
                if (!folderChildren.has(p.associated_folder)) folderChildren.set(p.associated_folder, []);
                folderChildren.get(p.associated_folder).push({...p, __kind:'folder'});
            }
        });

        files.forEach(f => {
            if (f.associated_folder == null) {
                if (!wsChildren.has(f.connected_workspace)) wsChildren.set(f.connected_workspace, []);
                wsChildren.get(f.connected_workspace).push({...f, __kind:'file'});
            } else {
                if (!folderChildren.has(f.associated_folder)) folderChildren.set(f.associated_folder, []);
                folderChildren.get(f.associated_folder).push({...f, __kind:'file'});
            }
        });

        const flat = [];
        function addNode(item, parentId, level, kind) {
            const prefix = kind === 'workspace' ? 'ws' : kind === 'folder' ? 'folder' : 'file';
            const id = `${prefix}-${item.id}`;
            const children = kind === 'workspace' ? (wsChildren.get(item.id) || []) : (kind === 'folder' ? (folderChildren.get(item.id) || []) : []);
            flat.push({
                id,
                rawId: item.id,
                label: item.name,
                type: kind,
                parentId,
                level,
                hasChildren: children.length > 0,
                expanded: true
            });
            for (const c of children) {
                if (c.__kind === 'file') addNode(c, id, level + 1, 'file');
                else addNode(c, id, level + 1, 'folder');
            }
        }

        for (const ws of workspaces) addNode(ws, null, 0, 'workspace');
        return flat;
    }

    // ---------- 数据与可见列表 ----------
    let flatData = buildFlat(); // 扁平数组（可以在运行时修改）
    let visibleList = [];       // 根据 expanded 计算出的可见列表（虚拟化用）
    let filteredSet = null;     // 搜索时的保留 id 集合（null 表示未搜索）

    // ---------- 帮助函数 ----------
    function buildMap(data){ const m = new Map(); data.forEach(n=>m.set(n.id, n)); return m; }

    // 获取一个节点的所有后代 id（包含子、子孙）
    function getDescendants(data, nodeId){
        const map = buildMap(data);
        const out = [];
        const stack = [nodeId];
        while(stack.length){
            const cur = stack.pop();
            for(const n of data){
                if(n.parentId === cur){
                    out.push(n.id);
                    stack.push(n.id);
                }
            }
        }
        return out;
    }

    // 计算 visibleList：当没有搜索时，visible = 所有祖先都 expanded 的节点（根始终可见）
    // 当有搜索（filteredSet不为null）时：visible = filteredSet 中的节点（保持原序）
    // 并自动确保在搜索时父节点 expanded=true（这样可以显示孩子）
    function computeVisible(){
        if(filteredSet){
            // 搜索模式：返回被保留的节点（保持原序），并确保父节点 expanded true
            const map = buildMap(flatData);
            const output = flatData.filter(n => filteredSet.has(n.id));
            // ensure parent's expanded for displayed nodes
            for(const n of output){
                let p = n.parentId;
                while(p){
                    const parent = output.find(x => x.id === p);
                    if(parent) parent.expanded = true;
                    p = map.get(p)?.parentId || null;
                }
            }
            visibleList = output;
        } else {
            const map = buildMap(flatData);
            const out = [];
            for(const node of flatData){
                if(!node.parentId) { out.push(node); continue; } // root
                // check all ancestors expanded
                let p = node.parentId;
                let ok = true;
                while(p){
                    const parent = map.get(p);
                    if(!parent || parent.expanded === false){ ok = false; break; }
                    p = parent.parentId;
                }
                if(ok) out.push(node);
            }
            visibleList = out;
        }
        phantom.style.height = `${visibleList.length * ITEM_H}px`;
    }

    // ---------- 虚拟化渲染 ----------
    let scrollTop = 0;

    function renderWindow(){
        const h = container.clientHeight || 400;
        const visibleCount = Math.ceil(h / ITEM_H);
        const start = Math.max(0, Math.floor(scrollTop / ITEM_H) - BUFFER);
        const end = Math.min(visibleList.length, start + visibleCount + BUFFER*2);
        const startY = start * ITEM_H;
        win.style.transform = `translateY(${startY}px)`;
        win.innerHTML = '';

        for(let i=start;i<end;i++){
            const node = visibleList[i];
            const row = document.createElement('div');
            row.className = 'row';
            row.draggable = true;
            row.dataset.index = i;
            row.dataset.id = node.id;
            row.style.height = ITEM_H + 'px';
            // content layout
            const content = document.createElement('div');
            content.style.display = 'flex';
            content.style.alignItems = 'center';
            content.style.width = '100%';
            // indent
            const indent = document.createElement('div');
            indent.style.width = (node.level * INDENT) + 'px';
            indent.style.flex = '0 0 auto';
            content.appendChild(indent);
            // toggle
            const toggle = document.createElement('div');
            toggle.className = 'toggle';
            toggle.innerText = node.hasChildren ? (node.expanded ? '▾' : '▸') : '';
            toggle.addEventListener('click', (e)=>{
                e.stopPropagation();
                node.expanded = !node.expanded;
                computeVisible();
                renderWindow();
            });
            content.appendChild(toggle);
            // icon & label
            const icon = document.createElement('div');
            icon.className = 'icon';
            icon.innerHTML = node.type === 'workspace' ? '🖴' : (node.type==='folder' ? '📁' : '📄');
            content.appendChild(icon);
            const label = document.createElement('div');
            label.className = 'label';
            // highlight if searching
            const q = searchInput.value.trim();
            label.innerHTML = highlightLabel(node.label, q);
            content.appendChild(label);

            row.appendChild(content);

            // drag events
            row.addEventListener('dragstart', (ev)=>{
                ev.dataTransfer.setData('text/plain', node.id);
                row.classList.add('dragging');
                draggingId = node.id;
                // show allowed effect
                ev.dataTransfer.effectAllowed = 'move';
            });
            row.addEventListener('dragend', (ev)=>{
                row.classList.remove('dragging');
                draggingId = null;
                hideDropIndicator();
                clearRowOverClasses();
            });

            // dragover -> show indicator (before/after/inside)
            row.addEventListener('dragover', (ev)=>{
                ev.preventDefault();
                const rect = row.getBoundingClientRect();
                const y = ev.clientY - rect.top;
                const mode = calculateDropPosition(y, rect.height);
                showDropIndicatorForRow(row, mode);
                setRowOverClass(row, mode);
                ev.dataTransfer.dropEffect = 'move';
            });

            row.addEventListener('dragleave', (ev)=>{
                clearRowOverClasses(row);
                hideDropIndicator();
            });

            row.addEventListener('drop', (ev)=>{
                ev.preventDefault();
                hideDropIndicator();
                clearRowOverClasses(row);
                const sourceId = ev.dataTransfer.getData('text/plain');
                const targetId = node.id;
                const rect = row.getBoundingClientRect();
                const y = ev.clientY - rect.top;
                const mode = calculateDropPosition(y, rect.height);
                handleMove(sourceId, targetId, mode);
            });

            // double click to toggle
            row.addEventListener('dblclick', ()=> {
                if(node.hasChildren){ node.expanded = !node.expanded; computeVisible(); renderWindow(); }
            });

            win.appendChild(row);
        }
    }

    // helper to set visual classes for over state
    function clearRowOverClasses(specificRow){
        const rows = win.querySelectorAll('.row');
        rows.forEach(r => r.classList.remove('over-before','over-after','over-inside'));
        if(specificRow) specificRow.classList.remove('over-before','over-after','over-inside');
    }
    function setRowOverClass(row, mode){
        clearRowOverClasses();
        if(mode === 'before') row.classList.add('over-before');
        else if(mode === 'after') row.classList.add('over-after');
        else row.classList.add('over-inside');
    }

    // show drop indicator line or inside highlight
    function showDropIndicatorForRow(row, mode){
        const rect = row.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        if(mode === 'before'){
            dropIndicator.style.display = 'block';
            dropIndicator.style.left = '0px';
            dropIndicator.style.top = (rect.top - containerRect.top) + 'px';
            dropIndicator.style.width = container.clientWidth + 'px';
        } else if(mode === 'after'){
            dropIndicator.style.display = 'block';
            dropIndicator.style.left = '0px';
            dropIndicator.style.top = (rect.bottom - containerRect.top) + 'px';
            dropIndicator.style.width = container.clientWidth + 'px';
        } else {
            dropIndicator.style.display = 'none';
            row.classList.add('over-inside');
        }
    }
    function hideDropIndicator(){
        dropIndicator.style.display = 'none';
    }

    // 根据鼠标 y 在目标行位置判断 mode
    function calculateDropPosition(y, h){
        const t = h * 0.25;
        if(y < t) return 'before';
        if(y > h - t) return 'after';
        return 'inside';
    }

    // ---------- 移动逻辑（更新 flatData） ----------
    // 需要移动 source 节点（及其所有后代）到 target（position: 'inside'|'before'|'after')
    function handleMove(sourceId, targetId, position){
        if(!sourceId || !targetId) return;
        if(sourceId === targetId) return;

        // prevent move into its own descendant
        const descendants = getDescendants(flatData, sourceId);
        if(descendants.includes(targetId)){
            alert('不允许把父节点移动到自己的子孙节点里');
            return;
        }

        // find source node and subtree
        const map = buildMap(flatData);
        const source = map.get(sourceId);
        const target = map.get(targetId);
        if(!source || !target) return;

        // collect subtree nodes (including source)
        const subtreeIds = [sourceId, ...getDescendants(flatData, sourceId)];
        const subtreeNodes = flatData.filter(n => subtreeIds.includes(n.id));

        // remove subtree nodes from flatData (temporarily)
        const remaining = flatData.filter(n => !subtreeIds.includes(n.id));

        // decide new parentId for the source
        let newParentId = null;
        let newLevel = 0;
        if(position === 'inside'){
            newParentId = target.id;
            newLevel = target.level + 1;
        } else { // before/after -> same parent as target
            newParentId = target.parentId;
            newLevel = (target.parentId ? map.get(target.parentId).level + 1 : 0);
        }

        // update source node parentId & level
        const levelDelta = newLevel - source.level;
        // update subtree levels and parentIds (only source changes parentId; descendants keep structure relative)
        const idToNode = new Map(flatData.map(n=>[n.id,{...n}]));
        // apply to subtreeNodes: update level by delta; the relative parentId stays same if parent is within subtree,
        // otherwise if parent was outside (shouldn't happen), we keep parentId as is.
        for(const n of subtreeNodes){
            const clone = idToNode.get(n.id);
            clone.level = n.level + levelDelta;
            if(n.id === source.id){
                clone.parentId = newParentId;
            }
            idToNode.set(n.id, clone);
        }

        // rebuild flatData: remaining nodes + inserted subtree at proper place (after computing insertion index)
        // find index to insert: if position inside => find index of target and insert after all its descendants
        // if before => insert at target's start index; if after => after target's descendants
        function findInsertIndex(list, refId, mode){
            // list is 'remaining' (original order preserved)
            // find index of refId in remaining; if not found (ref inside moved subtree previously), fallback to end
            const idx = list.findIndex(x => x.id === refId);
            if(idx === -1) return list.length;
            if(mode === 'before') return idx;
            // for 'after' and 'inside', insert after all descendants of refId that exist in 'list'
            let insert = idx + 1;
            for(let i=idx+1;i<list.length;i++){
                let p = list[i].parentId;
                let isDesc = false;
                while(p){
                    if(p === refId){ isDesc = true; break; }
                    p = map.get(p)?.parentId || null;
                }
                if(isDesc) insert = i + 1;
                else break;
            }
            return insert;
        }

        const insertIndex = findInsertIndex(remaining, targetId, position);
        // build new flat: splice subtree (with updated nodes in correct order)
        const newSubtree = [];
        // we must keep original relative order of subtreeNodes as they were in flatData
        for(const n of flatData){
            if(subtreeIds.includes(n.id)){
                const updated = idToNode.get(n.id);
                newSubtree.push(updated);
            }
        }

        const newFlat = [...remaining.slice(0, insertIndex), ...newSubtree, ...remaining.slice(insertIndex)];

        // update hasChildren flags
        const parentChildCount = new Map();
        for(const n of newFlat){
            if(n.parentId){
                parentChildCount.set(n.parentId, (parentChildCount.get(n.parentId) || 0) + 1);
            }
        }
        for(const n of newFlat){
            n.hasChildren = !!parentChildCount.get(n.id);
        }

        // commit
        flatData = newFlat;
        // reset any filteredSet (we keep search active but recompute)
        if(filteredSet){
            // re-run search to compute filteredSet again based on labels (keeps semantics)
            filteredSet = runSearchSet(searchInput.value.trim());
        }
        computeVisible();
        renderWindow();
    }

    // ---------- 搜索功能（保留匹配 + 父节点 + 直属子） ----------
    function runSearchSet(keyword){
        if(!keyword || !keyword.trim()) return null;
        const key = keyword.toLowerCase();
        const map = buildMap(flatData);
        const matched = new Set();
        // matched nodes
        for(const n of flatData){
            if(n.label.toLowerCase().includes(key)) matched.add(n.id);
        }
        // add parents
        for(const id of Array.from(matched)){
            let p = map.get(id)?.parentId || null;
            while(p){
                matched.add(p);
                p = map.get(p)?.parentId || null;
            }
        }
        // add direct children
        for(const id of Array.from(matched)){
            for(const n of flatData) if(n.parentId === id) matched.add(n.id);
        }
        return matched;
    }

    // ---------- UI events ----------
    let draggingId = null;

    container.addEventListener('scroll', (ev)=>{
        scrollTop = container.scrollTop;
        renderWindow();
    });

    // refresh
    btnRefresh.addEventListener('click', ()=>{
        flatData = buildFlat();
        filteredSet = null;
        computeVisible();
        renderWindow();
    });
    // expand/collapse all
    btnExpandAll.addEventListener('click', ()=>{
        flatData.forEach(n => n.expanded = true);
        computeVisible();
        renderWindow();
    });
    btnCollapseAll.addEventListener('click', ()=>{
        flatData.forEach(n => n.expanded = false);
        computeVisible();
        renderWindow();
    });

    // search input
    let searchTimer = null;
    searchInput.addEventListener('input', (ev)=>{
        if(searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(()=>{
            const v = searchInput.value.trim();
            filteredSet = runSearchSet(v);
            computeVisible();
            renderWindow();
        }, 160);
    });

    // initial render
    function init(){
        flatData = buildFlat();
        computeVisible();
        renderWindow();
    }
    init();

    // helper to highlight in label (used in render)
    function highlightLabel(label, q){
        if(!q) return escapeHtml(label);
        const idx = label.toLowerCase().indexOf(q.toLowerCase());
        if(idx === -1) return escapeHtml(label);
        const pre = escapeHtml(label.slice(0, idx));
        const mid = escapeHtml(label.slice(idx, idx + q.length));
        const post = escapeHtml(label.slice(idx + q.length));
        return `${pre}<mark>${mid}</mark>${post}`;
    }
    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // click outside to hide indicator
    document.addEventListener('dragover', (ev) => { ev.preventDefault(); }); // allow drop
</script>
</body>
</html>
